function [edata, trial_data] = exp_data_generate(edata)
% Generate trial_data for experiment

    % for debugging purposes
    if ~exist('edata', 'var'), edata = struct('subject_id', 0); end;

%% setup parameters
    
    % trial_data will be the variabel containing all our data for each trial in the
    % experiment. for now, we just initialize it.
    trial_data = [];

    % declare parameters outside of the data generation so that we can easily change
    % the experiment in the future.
    edata.parameters.block_count = 4;
    edata.parameters.trials_per_block = 64;
    edata.parameters.ssd.staircase_values = [.050 .200 .050 .200];
    edata.parameters.ssd.increment = .050;
    edata.parameters.ssd.minimum = .050;
               
%% seed random generator

    rand('state', edata.subject_id);

%% generate data for each block

    for block = 1:edata.parameters.block_count       

        block_data = {
            'go'        'left'      NaN         ; ...
            'go'        'right'     NaN         ; ...
            'go'        'left'      NaN         ; ...
            'go'        'right'     NaN         ; ...
            'go'        'left'      NaN         ; ...
            'go'        'right'     NaN         ; ...
            'go'        'left'      NaN         ; ...
            'go'        'right'     NaN         ; ...
            'go'        'left'      NaN         ; ...
            'go'        'right'     NaN         ; ...
            'go'        'left'      NaN         ; ...
            'go'        'right'     NaN         ; ...
            'stop'      'left'      1           ; ...
            'stop'      'left'      2           ; ...
            'stop'      'right'     3           ; ...
            'stop'      'right'     4           ; ...
            };
            
        % repeat the matrix to reach the necessary number of trials per block
        needed_replications = edata.parameters.trials_per_block / size(block_data, 1);
        block_data = repmat(block_data, needed_replications, 1);
        
        % randomize the entire block
        %   randperm_chop is based on randperm(). when given a cell array like block
        %   data, it will randomize by row. type 'help randperm_chop' for more info
        block_data = randperm_chop(block_data);
        
        % convert block_data to a dataset
        %   the dataset command takes the data, followed by a string for each column name
        block_data = dataset({block_data, 'trial_type', 'direction', 'staircase_index' } );
                
        % change columns that contain strings to the nominal data type
        %   this allows us to use syntax like "data.trial_type=='go'"
        block_data = dataset_nominalize_fields(block_data, {'trial_type', 'direction'});
        
        % change columns that contain numbers to be numbers
        block_data = dataset_numericize_fields(block_data, {'staircase_index'});
                
        % add a column for the block number
        block_data = dataset_add_columns(block_data, 'block', block);
        
        % append to trial_data
        %   the first time we do this, trial_data is empty. the dataset_append()
        %   function not only appends the rows from block_data, it also makes sure
        %   the output has all the columns from both inputs
        trial_data = dataset_append(trial_data, block_data);
    end
           
%% final formatting

    % that is it in terms of coding the conditions of the trials themselves.
    % for coding clarity, a separate function, exp_data_format(), appends all the
    % other necessary but routine columns and cleans up the data
    %
    % the other advantage is that if the experiment involves practice trials, the
    % practice data can be generated by a function similar to exp_data_generate (this
    % file), but it can also call exp_data_format to finish the process

    [trial_data] = exp_data_format(edata, trial_data);
    
end